name: Deploy Minecraft Server

on:
  pull_request:
    types: [closed]
    branches: [ "main" ]
    paths:
      - 'helm/**'
      - 'docker/**'
      - 'Dockerfile'
      - '.github/workflows/**'

env:
  # Define aqu√≠ el nombre de tu imagen en Docker Hub
  IMAGE_NAME: nicolasestevez/minecraft-survival 

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: Deploy
    # Solo ejecutar si el PR fue mergeado (no solo cerrado)
    if: github.event.pull_request.merged == true
    
    steps:
      - name: üì• Bajar c√≥digo del repositorio
        uses: actions/checkout@v4

      - name: üîê Login en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üè∑Ô∏è Generar Tag de Versi√≥n
        id: meta
        run: |
          # Creamos una variable VERSION = v1.0.numero_de_ejecucion
          echo "VERSION=v1.0.${{ github.run_number }}" >> $GITHUB_ENV
          echo "La nueva versi√≥n ser√°: v1.0.${{ github.run_number }}"

      - name: üê≥ Construir y Subir Imagen (Build & Push)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # Subimos dos tags: el espec√≠fico (v1.0.55) y el latest
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.VERSION }}
            ${{ env.IMAGE_NAME }}:latest

      - name: ‚ò∏Ô∏è Instalar Helm
        uses: azure/setup-helm@v3

      - name: üîå Configurar Kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: üöÄ Desplegar en Kubernetes
        run: |
          # Funci√≥n de Reintento (Exponential Backoff)
          function retry {
            local retries=$1
            shift
            local count=0
            until "$@"; do
              exit=$?
              wait=$((2 ** count))
              count=$((count + 1))
              if [ $count -lt $retries ]; then
                echo "‚ö†Ô∏è Fallo en intento $count/$retries. Reintentando en $wait segundos..."
                sleep $wait
              else
                echo "‚ùå Fallo definitivo despu√©s de $retries intentos."
                return $exit
              fi
            done
            return 0
          }

          echo "Desplegando versi√≥n: ${{ env.VERSION }}"
          
          # Registramos el repo de itzg
          helm repo add itzg https://itzg.github.io/minecraft-server-charts/
          retry 3 helm repo update

          # Creamos el secreto para bajar la imagen (si es privada)
          # Guardamos en archivo temporal para poder reintentar el 'kubectl apply'
          kubectl create secret docker-registry regcred \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username="${{ secrets.DOCKER_USERNAME }}" \
            --docker-password="${{ secrets.DOCKER_PASSWORD }}" \
            --namespace minecraft \
            --dry-run=client -o yaml > regcred.yaml
            
          retry 5 kubectl apply -f regcred.yaml
          rm regcred.yaml

          # Verificaci√≥n r√°pida del secreto
          echo "Verificando existencia del secreto regcred..."
          retry 3 kubectl get secret regcred -n minecraft

          # ==================================================================================
          # AVISO EN EL JUEGO + GUARDADO (Pre-Deploy)
          # Intentamos mandar un mensaje al server actual si est√° vivo
          # ==================================================================================
          echo "üì¢ Notificando a los jugadores y guardando..."
          # Buscamos el pod actual (si existe)
          POD_NAME=$(kubectl get pods -n minecraft -l app=survival-server-minecraft -o jsonpath="{.items[0].metadata.name}" || echo "")
          
          if [ ! -z "$POD_NAME" ]; then
            echo "Pod encontrado: $POD_NAME"
            # Mandamos alerta RCON
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "title @a title {\"text\":\"‚ö† ACTUALIZACI√ìN ‚ö†\",\"color\":\"red\"}" || true
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "title @a subtitle {\"text\":\"Reinicio en 30s - Guardando datos...\",\"color\":\"yellow\"}" || true
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "say ¬ßc‚ö† SERVIDOR REINICIANDO PARA ACTUALIZACI√ìN ‚ö†" || true
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "say ¬ßeGuardando mundo..." || true
            
            # Forzamos guardado
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "save-all" || true
            
            # BACKUP DE EMERGENCIA
            echo "üì¶ Generando backup de emergencia (world)..."
            kubectl exec -n minecraft "$POD_NAME" -- rcon-cli "say ¬ß7[System] Creando copia de seguridad..." || true
            # Usamos el script unificado de backup (con save-off/trap)
            kubectl exec -n minecraft "$POD_NAME" -- /usr/local/bin/essentials-backup.sh || echo "‚ö† Aviso: El backup fall√≥, pero continuamos."

            # Esperamos un poco para que lean el mensaje
            sleep 5
          else
            echo "No se encontr√≥ un pod activo. Saltando notificaci√≥n ingame."
          fi

          # Actualizamos Helm inyectando la imagen exacta que acabamos de crear
          # A√ëADIDO: Reintento de 5 veces para evitar "dial tcp i/o timeout"
          retry 5 helm upgrade --install survival-server itzg/minecraft \
            --version 4.19.0 \
            --namespace minecraft \
            -f helm/minecraft-values.yaml \
            --set image.repository=${{ env.IMAGE_NAME }} \
            --set image.tag=${{ env.VERSION }}

          # WORKAROUND: El chart de itzg no usa imagePullSecrets del values.yaml
          # Inyectamos el secreto manualmente en el Deployment
          echo "Inyectando imagePullSecrets en el Deployment..."
          retry 3 kubectl patch deployment survival-server-minecraft -n minecraft -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"regcred"}]}}}}'

          # Aplicamos el CronJob de reinicio autom√°tico
          echo "Aplicando Permisos RBAC y CronJob de reinicio..."
          retry 3 kubectl apply -f docker/scripts/restart-rbac.yaml
          retry 3 kubectl apply -f docker/scripts/minecraft-restart.yaml

          # Aplicamos el CronJob de Manenimiento (Limpieza de Backups y Logs)
          echo "Aplicando CronJob de limpieza..."
          retry 3 kubectl apply -f docker/scripts/maintenance-cronjob.yaml
          
          # Aplicamos Limpieza de Sistema (Imagenes y Pods)
          echo "Aplicando Limpieza de Sistema (K3s)..."
          retry 3 kubectl apply -f docker/scripts/k8s-cleaner.yaml

          # Forzamos el reinicio para asegurar que baje la nueva imagen
          kubectl rollout restart deployment/survival-server-minecraft -n minecraft
          
          # Esperamos a que el despliegue se complete (timeout 10min)
          echo "Esperando a que el nuevo pod arranque..."
          kubectl rollout status deployment/survival-server-minecraft -n minecraft --timeout=10m

      - name: üîî Notificar √âxito a Discord
        uses: rjstone/discord-webhook-notify@v1
        if: success()
        with:
          severity: info
          username: "Minecraft Server"
          details: "üöÄ **¬°Servidor Actualizado!** (Versi√≥n: `${{ env.VERSION }}`)"
          webhookUrl: ${{ secrets.DISCORD_WEBHOOK_URL }}

      - name: üö® Notificar Fallo a Discord
        uses: rjstone/discord-webhook-notify@v1
        if: failure()
        with:
          severity: error
          username: "GitOps Deployer"
          details: |
            ‚ùå **Despliegue FALLIDO**
            Versi√≥n Intentada: `${{ env.VERSION }}`
            Verifica los logs en GitHub Actions.
            [Ver Error](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          webhookUrl: ${{ secrets.DISCORD_WEBHOOK_URL_PRIVATE }}
